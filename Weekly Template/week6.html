<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Week 6</title>
    <link rel="stylesheet" href="/style/style.css" />
</head>

<body>
    <section>
        <h2>Section 1 :- Custom JWT Token using System Class and Microsoft's Class</h2>
        <p>A custom JWT (JSON Web Token) implementation utilizing both the System class and Microsoft's libraries can
            enhance security and tailor authentication mechanisms to specific requirements. Leveraging the System
            namespace, developers can manage core functionalities such as cryptographic operations and token generation.
            Meanwhile, Microsoft's libraries, like System.IdentityModel.Tokens.Jwt, provide comprehensive support for
            JWT handling, including validation and parsing.
        </p>
        <p>To create a custom JWT token, developers can start by defining the token's payload, which typically includes
            user information and metadata. Utilizing the JwtSecurityToken class from Microsoft's library, they can then
            construct the token by specifying the payload, signing key, and cryptographic algorithms. Employing
            SecurityTokenHandler classes facilitates token serialization and deserialization, ensuring compatibility
            across systems.
        </p>
        <p>
            Furthermore, integrating additional security measures like token expiration and audience restrictions can be
            achieved through the TokenValidationParameters class, enhancing the token's resilience against unauthorized
            access and misuse. By combining functionalities from both the System namespace and Microsoft's libraries,
            developers can craft robust and tailored JWT solutions suited to diverse authentication scenarios,
            bolstering
            application security and user trust.
        </p>

        <p>JWT Token Demo</p>
        <pre>
<code>
    using CustomJWTBearerTokenAPI.Models;
    using Microsoft.IdentityModel.Tokens;
    using Newtonsoft.Json.Linq;
    using System;
    using System.Collections.Generic;
    using System.IdentityModel.Tokens.Jwt;
    using System.Security.Claims;
    using System.Security.Cryptography;
    using System.Security.Principal;
    using System.Text;
    
    namespace CustomJWTBearerTokenAPI.Business_Logic
    {
        public class BLToken
        {
            // The secret key used for signing and validating JWT tokens
            private const string secretKey = "thisissecuritykeyofcustomjwttokenaut";
    
            /// &lt;summary>
            /// Generates a JWT token for the provided user.
            /// &lt;/summary>
            /// &lt;param name="objUser">The user for whom the token is generated.&lt;/param>
            /// &lt;returns>The generated JWT token as a string.&lt;/returns>
            internal static string GenerateToken(USR01 objUser)
            {
                string issuer = "CustomJWTBearerTokenAPI";
    
                // Creating SymmetricSecurityKey and SigningCredentials
                SymmetricSecurityKey symmetricSecurityKey = new SymmetricSecurityKey(
                    Encoding.UTF8.GetBytes(secretKey));
                SigningCredentials credentials = new SigningCredentials(symmetricSecurityKey,
                    SecurityAlgorithms.HmacSha256);
    
                // Creating claims for the user
                List&lt;Claim> claims = new List&lt;Claim>
                {
                    new Claim(ClaimTypes.Name, objUser.R01F02),
                    new Claim("Id", objUser.R01F01.ToString())
                };
    
                // Creating JWT token with claims and signing credentials
                JwtSecurityToken token = new JwtSecurityToken(issuer, issuer, claims,
                    expires: DateTime.Now.AddHours(1),
                    signingCredentials: credentials);
    
                JwtSecurityTokenHandler handler = new JwtSecurityTokenHandler();
                return handler.WriteToken(token);
            }
    
            /// &lt;summary>
            /// Gets the IPrincipal object from the provided JWT token.
            /// &lt;/summary>
            /// &lt;param name="token">The JWT token.&lt;/param>
            /// &lt;returns>The IPrincipal object representing the user./&lt;returns>
            internal static IPrincipal GetPrincipal(string token)
            {
                // Extracting and decoding the payload from the JWT token
                string jwtEncodePayload = token.Split('.')[1];
                int mod = jwtEncodePayload.Length % 4;
                int padding = mod > 0 ? 4 - mod : 0;
                jwtEncodePayload = jwtEncodePayload + new string('=', padding);
    
                try
                {
                    string decodedPayloadBytes = Encoding.UTF8.GetString(Convert.FromBase64String(jwtEncodePayload));
                    JObject json = JObject.Parse(decodedPayloadBytes);
    
                    // Retrieving user information based on the decoded payload
                    USR01 user = BLUser.GetUser(int.Parse(json["Id"].ToString()));
    
                    // Creating GenericIdentity and GenericPrincipal objects for the user
                    GenericIdentity identity = new GenericIdentity(user.R01F02);
                    IPrincipal principal = new GenericPrincipal(identity, user.R01F04.Split(','));
    
                    return principal;
                }
                catch (Exception ex)
                {
                    System.Diagnostics.Debug.WriteLine(ex.Message);
                    return null;
                }
            }
    
            /// &lt;summary>
            /// Validates if the provided JWT token is valid and not expired.
            /// &lt;/summary>
            /// &lt;param name="jwt">The JWT token to validate.&lt;/param>
            /// &lt;returns>True if the token is valid and not expired, false otherwise.&lt;/returns>
            internal static bool IsJwtValid(string jwt)
            {
                // Splitting the JWT token into header, payload, and hash parts
                string[] jwtArray = jwt.Split('.');
                string jwtHeader = jwtArray[0];
                string jwtPayload = jwtArray[1];
                string jwtHash = jwtArray[2];
    
                string payload = jwtHeader + "." + jwtPayload;
    
                // Calculating HMAC-SHA-256 for the header and payload
                var hash = new HMACSHA256(Encoding.UTF8.GetBytes(secretKey));
                byte[] digest = hash.ComputeHash(Encoding.UTF8.GetBytes(payload));
    
                string digestBase64 = Convert.ToBase64String(digest)
                    .Replace('+', '-')
                    .Replace('/', '_')
                    .Replace("=", "");
    
                // If JWT hash matches the calculated hash, check for expiry time
                if (jwtHash.Equals(digestBase64))
                {
                    // If not expired, return true; otherwise, return false
    
                    // Getting current time
                    TimeSpan span = DateTime.UtcNow.Subtract(new DateTime(1970, 1, 1, 0, 0, 0));
                    long currTotalSecond = (long)span.TotalSeconds;
    
                    // Decoding jwtPayload from Base64
                    int mod = jwtPayload.Length % 4;
                    int padding = mod > 0 ? 4 - mod : 0;
    
                    string paddedJwtPayload = jwtPayload + new string('=', padding);
                    byte[] encodedData = Convert.FromBase64String(paddedJwtPayload);
                    string decodedData = Encoding.UTF8.GetString(encodedData);
    
                    // Deserializing the jwtPayload decoded string
                    var jwtPayloadObj = JwtPayload.Deserialize(decodedData);
    
                    // Getting exp (expiry) claim
                    object expiryTotalSecond;
                    jwtPayloadObj.TryGetValue("exp", out expiryTotalSecond);
    
                    long exp = (long)expiryTotalSecond;
    
                    // Comparing expiry and current time
                    if (exp >= currTotalSecond)
                    {
                        return true;
                    }
                }
                return false;
            }
        }
    }
</code>
        </pre>

        <h2>Section 2 :- Adding new functionalities & updation in Final Demo</h2>
        <p>1. Interface </p>

        <a target="_blank"
            href="https://github.com/RKITSoftware/Deep-Patel/blob/main/API/Advanced%20C%23%20Topics/C%23%20Advance/OnlineShoppingAPI/OnlineShoppingAPI/Interface/IBasicAPIService.cs">
            <p>IBasicAPIService.cs</p>
        </a>

        <a href="https://github.com/RKITSoftware/Deep-Patel/blob/main/API/Advanced%20C%23%20Topics/C%23%20Advance/OnlineShoppingAPI/OnlineShoppingAPI/Business%20Logic/BLCustomer.cs"
            target="_blank" rel="noopener noreferrer">
            <p>CLCustomerController.cs</p>
        </a>

        <p>2. Exception Logging</p>
        <a href="https://github.com/RKITSoftware/Deep-Patel/blob/main/API/Advanced%20C%23%20Topics/C%23%20Advance/OnlineShoppingAPI/OnlineShoppingAPI/Business%20Logic/BLHelper.cs"
            target="_blank" rel="noopener noreferrer">
            <p>BLHelper.cs</p>
        </a>

        <br>
        <p>3. Optimizing Methods and Adding Inline Comments and Summary Comments for better understanding of what code
            how works.</p>

        <p>4. Cart Module</p>
        <a href="https://github.com/RKITSoftware/Deep-Patel/blob/main/API/Advanced%20C%23%20Topics/C%23%20Advance/OnlineShoppingAPI/OnlineShoppingAPI/Business%20Logic/BLCart.cs"
            target="_blank" rel="noopener noreferrer">
            <p>BLCart.cs</p>
        </a>

        <a href="https://github.com/RKITSoftware/Deep-Patel/blob/main/API/Advanced%20C%23%20Topics/C%23%20Advance/OnlineShoppingAPI/OnlineShoppingAPI/Controllers/CLCartController.cs"
            target="_blank" rel="noopener noreferrer">
            <p>CLCartController.cs</p>
        </a>

        <p>5. Email based 2-step Verification</p>
        <p>6. Cookie based authentication</p>
        <p>7. Sending Order Attachment File to User</p>
        <p>8. Excel File send via Email</p>
        <p>9. Online Shopping Model Testing</p>
    </section>
</body>

</html>